struct VSOutput {
	float4 position : POSITION;
	float2 texCoord : TEXCOORD0;
	float3 eyeSpacePos : TEXCOORD1;
};

VSOutput particleSphereVS(
	float4 position : POSITION,
	float2 texCoord : TEXCOORD0,
	uniform float4x4 modelViewMatrix,
	uniform float4x4 projectionMatrix)
{
	VSOutput OUT;
	
	float4 eyeSpacePos = mul(modelViewMatrix, position);
	OUT.position = mul(projectionMatrix, eyeSpacePos);
	OUT.eyeSpacePos = eyeSpacePos.xyz;
	OUT.texCoord = texCoord;
	
	return OUT;
}

// ----------------------------------

struct PSOutput {
	float fragDepth : DEPTH;
	float4 fragColor : COLOR;
};

PSOutput particleSpherePS(
	float2 texCoord : TEXCOORD0, // TODO: check if correct value
	float3 eyeSpacePos : TEXCOORD1,
	uniform float sphereRadius, // TODO!: sync with PhysX params...
	//float4 color : COLOR0, // TODO later: use for density?
	uniform float4x4 projectionMatrix,
	uniform float3 lightDir,
	uniform float ambient) 
{
	float4 color = float4(0,0,1,1); 
	
	PSOutput OUT;
	//debug(float4(0,0,1,1)); --> doesn't work - why?
	
	// calculate eye-space sphere normal from texture coordinates
	float3 N;
	N.xy = texCoord*2.0-1.0;
	float r2 = dot(N.xy, N.xy);
	if (r2 > 1.0) discard; // kill pixels outside circle
	N.z = -sqrt(1.0 -r2);
	//N = -N;
	
	// calculate depth
	float4 pixelPos = float4(eyeSpacePos + (-N)*sphereRadius, 1.0);
	float4 clipSpacePos = mul(pixelPos, projectionMatrix);
	float mydepth = clipSpacePos.z / clipSpacePos.w;
	//if (mydepth <= OUT.fragDepth) // TODO: set near far clip for better depth range...
	//	discard;
	OUT.fragDepth = mydepth;
	float diffuse = max(0.0, dot(N, lightDir));

	OUT.fragColor = diffuse * color + ambient * color;
	
	OUT.fragColor = OUT.fragDepth;//float4(1,0,0,1);
	
	return OUT;
}